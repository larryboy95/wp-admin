#!/bin/bash

USAGE="
Usage: do-wp-new CONFIGFILE
Provisions a new droplet at Digitalocean and installs WordPress.

Config file vars required, (see do-new-wp.conf.example):
    HOSTNAME (alphanumeric and dashes only) 
    DOMAIN
    EMAIL
    DOTOKEN
    PUBLICKEY

ADMINIP is automatically obtained from eth0

Optional vars and their default values:
    SUBDOMAIN defaults to HOSTNAME
    SSHHOSTS ~/.ssh/config
    ANSIBLEHOSTS /etc/ansible/hosts
    PRIVATEKEY ~/.ssh/id_rsa
    DROPLETSIZE s-1vcpu-1gb
    IMAGE ubuntu-16-04-x64
    REGION sfo2
    WPUSER admin
    WILDCARD boolean defaults true
    ELASTICSEARCH boolean defaults false

Optional vars with no defaults.
Set these to trigger related feature.
    CODEBASE path of webroot to restore
    DB path to (.sql.gz) db to restore
    RESTICCODEBASE id of target snapshot to restore
    RESTICDB id of target db to restore
"
# Print USAGE if no args
if [ $# -eq 0 ]; then
    echo "$USAGE"
    exit 1
fi
SCRIPTDIR=$(dirname "${0}")
CONFIGPARSE="${SCRIPTDIR}/includes/config_parse"
[ -f "$1" ] || { echo "Config file not found"; exit 1; }
[ -f "$CONFIGPARSE" ] || { echo "Includes error"; exit 1; }

# If host exists then offer to overwrite
# Optionally restore a site to new droplet
function main {
    local FQDN 
    . "$CONFIGPARSE"
    ssh_config_check "$1"
    if [ $? -eq 1 ]; then
        wp_restore "$1"
        exit $?
    fi

    if [ ! -z "$DROPLETID" ]
        || [ ! -z "$DIP" ]; then
        echo "DROPLET variables already set"}
        exit 1
    else
        provision_do "$1"
        connection_test "$1"
        install_prerequisite "$1"
        provision_ansible "$1"
        install_wordpress "$1"
    fi

    if [ ! -z "$DB" ] \
        || [ ! -z "$RESTICDB" ]; then
        wp_restore "$1"
    fi

    echo "
***
    https://${FQDN}
***
    "
}

# Provision a new droplet
function provision_ansible {
    . "$CONFIGPARSE"
    ansible-playbook "${SCRIPTDIR}/ansible/wordpress.yml" --extra-vars "
        host=${HOSTNAME}
        adminip=${ADMINIP}
        mysql_root_password=${DBROOTPASS}
        mysql_wp_password=${DBWPPASS}
        fqdn=${FQDN}
        email=${EMAIL}
        domain=${DOMAIN}
        newcert=${NEWCERT}
        wildcard=${WILDCARD}
        wildcardchain=${WILDCARDCHAIN}
        elasticsearch=${ELASTICSEARCH}"
    if [ ! $? -eq 0 ]; then
        echo "Error running ansible."
        exit 1
    fi
}

# Run wordpress-install new / clone repo
# Preserve the fresh config file
function install_wordpress {
    . "$CONFIGPARSE"
    wordpress-install \
        "${HOSTNAME}" \
        "${FQDN}" \
        "${WPUSER}" \
        "${EMAIL}" \
        "${DBWPPASS}"
    if [ ! $? -eq 0 ]; then
        echo "Error running wordpress-install."
        exit 1
    fi
    ssh "${HOSTNAME}" "cp /var/www/html/wp-config.php /var/www/wp-config.php.fresh"
    if [ ! $? -eq 0 ]; then
        echo "Error copying config file."
        exit 1
    fi
    wordpress-permissions "$HOSTNAME" dev
    if [ ! $? -eq 0 ]; then
        echo "Error setting permissions."
        exit 1
    fi
}

# Provision the droplet and store its ID
# Get IP, setup SSH and Ansible config, create DNS A record
# Offer to delete droplet on exit
function provision_do {
    local DIDRAW DROPLETID DIPRAW DIP
    . "$CONFIGPARSE"
    echo "Provisioning new droplet for ${HOSTNAME}."
    DIDRAW=$(doctl compute droplet create \
        "$HOSTNAME" \
        -t "$DOTOKEN" \
        --ssh-keys "$PUBLICKEY" \
        --size "$DROPLETSIZE" \
        --image "$IMAGE" \
        --region "$REGION" \
        --enable-backups \
        --enable-monitoring \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error provisioning droplet."
        echo "${DIDRAW}"
        exit 1
    fi
    DROPLETID=$(echo "${DIDRAW}" | jq -j '.[0] .id')
    [ $? -eq 0 ] || { echo "Error parsing DIDRAW."; exit 1; }
    if [ -z "$DROPLETID" ]; then
        echo "Droplet ID is empty."
        echo "${DIDRAW}"
        exit 1
    else
        echo "Wait three seconds for the IP to become available....."
        sleep 3
    fi
    echo "DROPLETID=\"$DROPLETID\"" >> "$1"
    trap "doctl compute droplet delete -t ${DOTOKEN} ${DROPLETID}; sleep 3; doctl compute droplet list -t ${DOTOKEN}" EXIT

    while true; do
        DIPRAW=$(doctl compute droplet \
            get "${DROPLETID}" \
            -t "${DOTOKEN}" \
            -o json) 
        [ $? -eq 0 ] || { echo "Error getting IP."; exit 1; }
        DIP=$(echo "${DIPRAW}" | jq -j '.[0] .networks.v4[0].ip_address')
        [ $? -eq 0 ] || { echo "Error parsing JSON."; exit 1; }
        [ -z "$DIP" ] || break
    done
    echo "DIP=\"$DIP\"" >> "$1"
    ssh_config_add_host "$1" "$DIP" \
        || { echo "ssh config error $?"; exit 2; }
    ansible_add_host "$1" "$DIP" \
        || { echo "ansible config error $?"; exit 2; }
    do_add_record "$1" "$DIP" \
        || { echo "dns config error $?"; exit 2; }
}

function install_prerequisite {
    . "$CONFIGPARSE"
    [ -z "$HOSTNAME" ] && { echo "HOSTNAME not set"; exit 1; }
    echo "Install prerequisite packages."
    while true; do
        ssh -o ConnectTimeout=3 "${HOSTNAME}" \
            "DEBIAN_FRONTEND=noninteractive apt-get -y -q install python ssl-cert"
        if [ $? -eq 0 ]; then
            sleep 3
            break
        else
            echo "Error installing packages, trying again..."
        fi
    done
}

# Optionally run a restoration
function wp_restore {
    . "$CONFIGPARSE"
    if [ ! -z "$DB" ]; then
        read -p "Restore ${DB} to ${HOSTNAME}? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-local "$HOSTNAME" "$FQDN" "$DB" "$CODEBASE"
        else
            return 1
        fi
    elif [ -f ~/.wp-admin ] && [ ! -z "$RESTICDB" ]; then
        read -p "Restore restic snapshot ${RESTICDB} to ${HOSTNAME}? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-restic "$HOSTNAME" "$FQDN" "$RESTICDB" "$RESTICCODEBASE"
        else
            return 1
        fi
    fi
}

# Wait for the new droplet to become ready
function connection_test {
    . "$CONFIGPARSE"
    echo -ne "Wait for the droplet to become available..."
    while true; do
        ssh -o ConnectTimeout=3 -q "${HOSTNAME}" \
            "[ -f /var/lib/cloud/instance/boot-finished ]"
        if [ $? -eq 0 ]; then
            sleep 1
            echo -ne "\r"
            break
        else
            echo -ne "."
            sleep 1
        fi
    done
}

function ssh_config_check {
    local HOSTPATTERN
    . "$CONFIGPARSE"
    HOSTPATTERN="^Host ${HOSTNAME}$"
    if grep "$HOSTPATTERN" "${SSHHOSTS}"; then
        grep "$HOSTPATTERN" -A5 "${SSHHOSTS}"
        echo "${HOSTNAME} was found in ${SSHHOSTS}"
        connection_test "$1"
        return 1
    else
        return 0
    fi
}

function ssh_config_add_host {
    . "$CONFIGPARSE"
    DIP="$2"
    echo "Host ${HOSTNAME}
    HostName ${DIP}
    User root
    IdentityFile ${PRIVATEKEY}
    IdentitiesOnly yes
    " >> "${SSHHOSTS}"
}

function ansible_add_host {
    local DIP OLDIP HOSTPATTERN
    . "$CONFIGPARSE"
    DIP="$2"
    HOSTPATTERN="^${HOSTNAME} "
    TMP="/tmp/do-new-wp"
    [ ! -d "$TMP" ] && mkdir "$TMP"
    trap "rm -rf ${TMP}" EXIT	

    if grep "$HOSTPATTERN" "${ANSIBLEHOSTS}"; then
        echo "/n"
        read -p "${HOSTNAME} was found in ${ANSIBLEHOSTS}, update it with new IP? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Changing IP for $HOSTNAME in $ANSIBLEHOSTS"
            OLDIP=$(grep "$HOSTPATTERN" $ANSIBLEHOSTS | cut -d'=' -f3)
            [ ! $? -eq 0 ] && return 1
            sed "s/${OLDIP}/${DIP}/g" "$ANSIBLEHOSTS" > "${TMP}/anshosts"
            cat "${TMP}/anshosts" > "$ANSIBLEHOSTS"
            [ ! $? -eq 0 ] && return 1
        elif [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "Cancelled due to user request"
            return 0
        else
            return 1
        fi
    else
        echo "${HOSTNAME} ansible_port=22 ansible_host=${DIP}" >> "${ANSIBLEHOSTS}"
        [ ! $? -eq 0 ] && return 1
    fi
    return 0
}

function do_add_record {
    local DIP DNSRAW DNSID
    . "$CONFIGPARSE"
    DIP="$2"
    echo "Setup subdomain with Digitalocean DNS."
    DNSRAW=$(doctl compute domain records \
        create "${DOMAIN}" \
        -t "${DOTOKEN}" \
        --record-type A \
        --record-name "${SUBDOMAIN}" \
        --record-data "${DIP}" \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error creating dns record."
        return 1
    fi
    DNSID=$(echo "${DNSRAW}" | jq '.[0] .id')
    if [ ! $? -eq 0 ] || [ -z "$DNSID" ]; then
        echo "Error parsing JSON."
        echo "${DNSRAW}"
        echo "${DNSID}"
        return 1
    fi
    DNSID=$(echo "${DNSID}" | tr -d '\n')
    if [ -z "$DNSID" ]; then
        echo "DNSID is empty."
        return 1
    else
        echo "DNS A record for ${FQDN} to ${DIP} was created."
    fi
    return 0
}

main "$@"
exit 0
