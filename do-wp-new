#!/bin/bash

USAGE="
Deploys a WordPress site to a fresh droplet at digitalocean.

Requires a configuration file with Digitalocean API credentials, domain, and email, (see below).

With the bare minimum arguments (HOSTNAME), the script will download and install the latest version of WordPress on the new droplet.

If DB and CODEBASE are set, the script will then proceed to deploy an existing WordPress site with a fresh configuration file.

Each droplet is configured with letsencrypt. You may supply a wildcard certificate in '/etc/letsencrypt/archive/FQDN' (see le-wildcard) or request a certificate for the domain during the provisioning process (WILDCARD=\"no\").

Warning: If the host already exists in SSH config the script will  overwrite the contents of the existing droplet.

[ Note: This script is not be used to deploy directly to production. The purpose here is to rapidly spin up sites that will then be used for staging or modified by hand for use as a production server. ]

Usage: do-wp-new CONFIGFILE HOSTNAME [DB CODEBASE]

CONFIGFILE is the path to the config file for your DO account
HOSTNAME (alphanumeric and dashes only) 

Optional args with no defaults.
Set these to restore site from backup.
    DB path to (.sql.gz) db to restore
    CODEBASE path of webroot to restore

Config file vars required, (see do-new-wp.conf.example):
    DOMAIN the root domain where you will create subdomains
    EMAIL for letsencrypt and wordpress admin user
    DOTOKEN from the API tab of Digitalocean

ADMINIP is automatically obtained from eth0
(ssh access is restricted to this IP)

Optional vars and their default values:
    SUBDOMAIN defaults to HOSTNAME
    SSHHOSTS ~/.ssh/config
    ANSIBLEHOSTS /etc/ansible/hosts
    PUBLICKEY ~/.ssh/id_rsa.pub
    PRIVATEKEY ~/.ssh/id_rsa
    DROPLETSIZE s-1vcpu-1gb
    IMAGE ubuntu-16-04-x64
    REGION sfo2
    WPUSER admin
    WILDCARD defaults to yes
    ELASTICSEARCH defaults to no
"
# Print USAGE if no args
if [ $# -lt 2 ]; then
    echo "$USAGE"
    exit 1
fi
SCRIPTDIR=$(dirname "${0}")
CONFIGPARSE="${SCRIPTDIR}/includes/config_parse"
[ -f "$1" ] || { echo "Config file not found"; exit 1; }
[ -f "$CONFIGPARSE" ] || { echo "Includes error"; exit 1; }
DROPLETID=""
DROPLETADDR=""
DBROOTPASS=""
DBWPPASS=""
WPPASS=""
# Include helper functions
. "${SCRIPTDIR}/includes/helpers"
. "${SCRIPTDIR}/includes/dns"
. "${SCRIPTDIR}/includes/ssh"
. "${SCRIPTDIR}/includes/wordpress"

# If host exists then offer to overwrite
# Optionally restore a site to new droplet
function main {
    local FQDN 
    . "$CONFIGPARSE"
    ssh_config_check "$@"
    if [ $? -eq 1 ]; then
        wp_restore "$@"
        exit $?
    fi
    ssh_key_check "$@"
    if [ $? -eq 1 ]; then
        ssh_key_add "$@"
        [ $? -eq 0 ] || { echo "Could not add key ${PUBLICHASH}"; exit 2; }
    fi

    if [ ! -z "$DROPLETID" ] \
        || [ ! -z "$DROPLETADDR" ]; then
        echo "DROPLET variables already set"}
        exit 1
    else
        provision_do "$@"
        connection_test "$@"
        install_prerequisite "$@"
        provision_ansible "$@"
        install_wordpress "$@"
        os-authorize "$FQDN" dev
    fi

    if [ ! -z "$DB" ]; then
        wp_restore "$@"
    fi

    echo " 
     ***
         https://${FQDN}
     ***
    "
}

# Provision a new droplet
function provision_ansible {
    . "$CONFIGPARSE"
    ansible-playbook "${SCRIPTDIR}/ansible/wordpress.yml" --extra-vars "
        host=${FQDN}
        adminip=${ADMINIP}
        mysql_root_password=${DBROOTPASS}
        mysql_wp_password=${DBWPPASS}
        fqdn=${FQDN}
        email=${EMAIL}
        domain=${DOMAIN}
        newcert=${NEWCERT}
        wildcard=${WILDCARD}
        wildcardchain=${WILDCARDCHAIN}
        elasticsearch=${ELASTICSEARCH}"
    if [ ! $? -eq 0 ]; then
        echo "Error running ansible."
        exit 1
    fi
}


# Provision the droplet and store its ID
# Get IP, setup SSH and Ansible config, create DNS A record
# Offer to delete droplet on exit
function provision_do {
    local DIDRAW DIPRAW 
    . "$CONFIGPARSE"
    echo "Provisioning new droplet for ${FQDN}."
    DIDRAW=$(doctl compute droplet create \
        "$FQDN" \
        -t "$DOTOKEN" \
        --ssh-keys "$PUBLICHASH" \
        --size "$DROPLETSIZE" \
        --image "$IMAGE" \
        --region "$REGION" \
        --enable-backups \
        --enable-monitoring \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error provisioning droplet."
        echo "${DIDRAW}"
        exit 1
    fi
    DROPLETID=$(echo "${DIDRAW}" | jq -j '.[0] .id')
    [ $? -eq 0 ] || { echo "Error parsing DIDRAW."; exit 1; }
    if [ -z "$DROPLETID" ]; then
        echo "Droplet ID is empty."
        echo "${DIDRAW}"
        exit 1
    else
        echo "Wait three seconds for the IP to become available....."
        sleep 3
    fi
    trap "doctl compute droplet delete -t ${DOTOKEN} ${DROPLETID}; sleep 3; doctl compute droplet list -t ${DOTOKEN}" EXIT

    while true; do
        DIPRAW=$(doctl compute droplet \
            get "${DROPLETID}" \
            -t "${DOTOKEN}" \
            -o json) 
        [ $? -eq 0 ] || { echo "Error getting IP."; exit 1; }
        DROPLETADDR=$(echo "${DIPRAW}" | jq -j '.[0] .networks.v4[0].ip_address')
        [ $? -eq 0 ] || { echo "Error parsing JSON."; exit 1; }
        [ "$DROPLETADDR" != "null" ] && break
    done
    ssh_config_check "$@"
    if [ "$?" -eq 0 ]; then
        ssh_config_add_host "$@"
    else
        echo "Host exists in ${SSHHOSTS}"
        exit 2
    fi
    ansible_check_host "$@"
    if [ "$?" -eq 0 ]; then
        ansible_add_host "$@"
    else
        echo "Host exists in ${ANSIBLEHOSTS}"
        exit 2
    fi
    do_dns_check "$@"
    if [ "$?" -eq 0 ]; then
        do_dns_add "$@"
    else
        echo "DNS record exists"
        exit 2
    fi
}

function install_prerequisite {
    . "$CONFIGPARSE"
    [ -z "$HOSTNAME" ] && { echo "HOSTNAME not set"; exit 1; }
    echo "Install prerequisite packages."
    while true; do
        ssh -o ConnectTimeout=3 "${FQDN}" \
            "DEBIAN_FRONTEND=noninteractive apt-get -y -q install python ssl-cert"
        if [ $? -eq 0 ]; then
            sleep 3
            break
        else
            echo "Error installing packages, trying again..."
        fi
    done
}

# Optionally run a restoration
function wp_restore {
    . "$CONFIGPARSE"
    if [ ! -z "$DB" ]; then
        read -p "Restore to ${FQDN}. Are you sure? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-local "$FQDN" "$FQDN" "$DB" "$CODEBASE"
        else
            return 1
        fi
    fi
}


main "$@"
exit 0
