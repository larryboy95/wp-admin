#!/bin/bash

USAGE="
Usage: do-new-wp CONFIGFILE
Provisions a new droplet at Digitalocean and installs WordPress.

Config file vars required, (see do-new-wp.conf.example):
    NAME (alphanumeric and dashes only) 
    DOMAIN
    EMAIL
    DOTOKEN
    PUBLICKEY

ADMINIP is automatically obtained from eth0

Optional vars and their default values:
    SUBDOMAIN defaults to NAME
    SSHHOSTS ~/.ssh/config
    ANSHOSTS /etc/ansible/hosts
    PATHTOPRIVKEY ~/.ssh/id_rsa
    DROPLETSIZE s-1vcpu-1gb
    IMAGE ubuntu-16-04-x64
    REGION sfo2
    WPUSER admin
    WILDCARD boolean defaults true
    ELASTICSEARCH boolean defaults false

Optional vars with no defaults.
Set these to trigger related feature.
    CODEBASE path of webroot to restore
    DB path to (.sql.gz) db to restore
    RESTICCODEBASE id of target snapshot to restore
    RESTICDB id of target db to restore
"
# Print USAGE if no args
if [ $# -eq 0 ]; then
    echo "$USAGE"
    exit 1
fi

function main {
    local NAME CODEBASE DB RESTICCODEBASE RESTICDB
    local DOMAIN SUBDOMAIN FQDN SSHHOSTS
    # Include the config file
    . "$1"

    [ -z "$NAME" ] && { echo "NAME not set"; exit 1; }
    [ -z "$DOMAIN" ] && { echo "DOMAIN not set"; exit 1; }
    [ -z "$SUBDOMAIN" ] && SUBDOMAIN=${NAME}
    FQDN="${SUBDOMAIN}.${DOMAIN}"
    SSHHOSTS=${SSHHOSTS:-~/.ssh/config}

    # If host exists then offer to overwrite
    ssh_config_check "$NAME" "$SSHHOSTS"
    if [ $? -eq 1 ]; then
        wp_restore "$1" "$FQDN"
        exit $?
    fi

    do_provision "$1"

    # Optionally restore a site to new droplet
    if [ ! -z "$DB" ] \
        || [ ! -z "$RESTICDB" ]; then
        wp_restore "$1" "$FQDN"
    fi

    echo "
    ***

    https://${FQDN}

    ***
    "
}


# Provision a new droplet and install wordpress
function do_provision {
    local FQDN ADMINIP SCRIPTDIR WPUSER MYSQLROOTPASSWORD
    local SSHHOSTS ANSHOSTS PATHTOPRIVKEY DROPLETSIZE IMAGE REGION MYSQLWPPASSWORD
    local DIDRAW DID DIP TMP WILDCARDCHAIN NEWCERT
    # Include the config file
    . "$1"
    # TODO add ses creds
    # Check that required variables are set
    [ -z "$NAME" ] && { echo "NAME not set"; exit 1; }
    [ -z "$DOMAIN" ] && { echo "DOMAIN not set"; exit 1; }
    [ -z "$SUBDOMAIN" ] && SUBDOMAIN=${NAME}
    [ -z "$EMAIL" ] && { echo "EMAIL not set"; exit 1; }
    [ -z "$DOTOKEN" ] && { echo "DOTOKEN not set"; exit 1; }
    [ -z "$PUBLICKEY" ] && { echo "PUBLICKEY not set"; exit 1; }
    [ -z "$ELASTICSEARCH" ] && ELASTICSEARCH=false
    [ -z "$WILDCARD" ] && WILDCARD=true
    [ "$WILDCARD" ] && NEWCERT=false || NEWCERT=true
    [ "$WILDCARD" ] && WILDCARDCHAIN="/etc/letsencrypt/archive/${DOMAIN}" || echo "Wildcard not set"
    ADMINIP="$(ifconfig | grep -A 1 'eth0' | tail -1 | cut -d ':' -f 2 | cut -d ' ' -f 1)"
    FQDN="${SUBDOMAIN}.${DOMAIN}"
    SCRIPTDIR=$(dirname "${0}")
    # Set default values for optional variables
    SSHHOSTS=${SSHHOSTS:-~/.ssh/config}
    ANSHOSTS=${ANSHOSTS:-/etc/ansible/hosts}
    PATHTOPRIVKEY=${PATHTOPRIVKEY:-~/.ssh/id_rsa}
    DROPLETSIZE="${DROPLETSIZE:-s-1vcpu-1gb}"
    IMAGE=${IMAGE:-ubuntu-16-04-x64}
    REGION=${REGION:-sfo2}
    WPUSER=${WPUSER:-admin}
    # Generate db passwords
    MYSQLROOTPASSWORD=$(tr -dc 'a-zA-Z0-9' < /dev/urandom | fold -w 18 | head -n 1)
    MYSQLWPPASSWORD=$(tr -dc 'a-zA-Z0-9' < /dev/urandom | fold -w 18 | head -n 1)
    # Setup a tmp dir
    TMP="/tmp/do-new-wp"
    [ ! -d "$TMP" ] && mkdir "$TMP"
    # Cleanup on exit
    trap "rm -rf ${TMP}" EXIT	

    #if [ $(ssh_config_check "$NAME" "$SSHHOSTS") ]; then
        # add nonce
        # repeat until no conflicts
    #fi

    # Provision the droplet and store its ID
    echo "Provisioning new droplet for ${NAME}."
    DIDRAW=$(doctl compute droplet create \
        "$NAME" \
        -t "$DOTOKEN" \
        --ssh-keys "$PUBLICKEY" \
        --size "$DROPLETSIZE" \
        --image "$IMAGE" \
        --region "$REGION" \
        --enable-backups \
        --enable-monitoring \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error provisioning droplet."
        echo "${DIDRAW}"
        exit 1
    fi
    DIDRAW=$(echo "${DIDRAW}" | jq '.[0] .id')
    if [ ! $? -eq 0 ]; then
        echo "Error parsing JSON."
        echo "${DIDRAW}"
        exit 1
    fi
    DID=$(echo "${DIDRAW}" | tr -d '\n')
    if [ -z "$DID" ]; then
        echo "Droplet ID is empty."
        exit 1
    else
        echo "Wait three seconds for the IP to become available....."
        sleep 3
    fi
    # Offer to delete droplet on exit
    trap "doctl compute droplet delete -t ${DOTOKEN} ${DID}; sleep 3; doctl compute droplet list -t ${DOTOKEN}" EXIT
    # Get IP
    while true; do
        DIPRAW=$(doctl compute droplet \
            get "${DID}" \
            -t "${DOTOKEN}" \
            -o json) 
        if [ ! $? -eq 0 ]; then
            echo "Error retrieving droplet IP address."
            echo "$DIPRAW"
            exit 1
        fi
        DIPRAW=$(echo "${DIPRAW}" | jq '.[0] .networks.v4[0].ip_address')
        if [ ! $? -eq 0 ]; then
            echo "Error parsing JSON."
            exit 1
        fi
        DIP=$(echo "${DIPRAW}" | tr -d '\n' | tr -d '"')
        if [ -z "$DIP" ]; then
            echo "IP address is empty?"
            exit 1
        else
            break
        fi
    done
    # Get IP, setup SSH and Ansible config, create DNS A record
    ssh_config_add_host "$NAME" "$SSHHOSTS" "$DIP" "$PATHTOPRIVKEY" \
        || { echo "ssh config error $?"; exit 2; }
    ansible_add_host "$NAME" "$ANSHOSTS" "$DIP" \
        || { echo "ansible config error $?"; exit 2; }
    do_add_record "$SUBDOMAIN" "$DOMAIN" "$DIP" \
        || { echo "dns config error $?"; exit 2; }
    connection_test "$NAME"

### INSTALL SOFTWARE ###
    install_prerequisite "$NAME"
# Run ansible playbook to set up servers
    ansible-playbook "${SCRIPTDIR}/ansible" --extra-vars "
        host=${NAME}
        adminip=${ADMINIP}
        mysql_root_password=${MYSQLROOTPASSWORD}
        mysql_wp_password=${MYSQLWPPASSWORD}
        fqdn=${FQDN}
        email=${EMAIL}
        domain=${DOMAIN}
        newcert=${NEWCERT}
        wildcard=${WILDCARD}
        wildcardchain=${WILDCARDCHAIN}
        elasticsearch=${ELASTICSEARCH}"

    if [ ! $? -eq 0 ]; then
        echo "Error running ansible."
        exit 1
    fi

# Run wordpress-install new / clone repo
    wordpress-install \
        "${NAME}" \
        "${FQDN}" \
        "${WPUSER}" \
        "${EMAIL}" \
        "${MYSQLWPPASSWORD}"
    if [ ! $? -eq 0 ]; then
        echo "Error running wordpress-install."
        exit 1
    fi
# Preserve the fresh config file
    ssh "${NAME}" "cp /var/www/html/wp-config.php /var/www/wp-config.php.fresh"
    if [ ! $? -eq 0 ]; then
        echo "Error copying config file."
        exit 1
    fi

# Change webroot permissions
    wordpress-permissions "$NAME" dev
    if [ ! $? -eq 0 ]; then
        echo "Error setting permissions."
        exit 1
    fi
}

function install_prerequisite {
    local NAME
    NAME="$1"
    echo "Install prerequisite packages."
    while true; do
        ssh -o ConnectTimeout=3 "${NAME}" \
            "DEBIAN_FRONTEND=noninteractive apt-get -y -q install python ssl-cert"
        if [ $? -eq 0 ]; then
            sleep 3
            break
        else
            echo "Error installing packages, trying again..."
        fi
    done
    ssh "$NAME" "curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar; chmod +x wp-cli.phar; mv wp-cli.phar /usr/local/bin/wp"
    if [ ! $? -eq 0 ]; then
        echo "Error installing wp-cli."
        exit 1
    fi
}

# Optionally run a restoration
function wp_restore {
    local NAME FQDN DB CODEBASE RESTICDB RESTICCODEBASE
    CONFIG="$1"
    FQDN="$2"
    . "$CONFIG"
    if [ ! -z "$CODEBASE" ]; then
        read -p "Restore ${CODEBASE} to ${NAME}? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-local "$NAME" "$FQDN" "$DB" "$CODEBASE"
        else
            return 1
        fi
    elif [ -f ~/.wp-admin ] && [ ! -z "$RESTICCODEBASE" ]; then
        read -p "Restore restic snapshot ${RESTICCODEBASE} to ${NAME}? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-restic "$NAME" "$FQDN" "$RESTICDB" "$RESTICCODEBASE"
        else
            return 1
        fi
    fi
}

# Wait for the new droplet to become ready
function connection_test {
    local NAME
    NAME="$1"
    echo -ne "Wait for the droplet to become available..."
    while true; do
        ssh -o ConnectTimeout=3 -q "${NAME}" \
            "[ -f /var/lib/cloud/instance/boot-finished ]"
        if [ $? -eq 0 ]; then
            sleep 1
            echo -ne "\r"
            break
        else
            echo -ne "."
            sleep 1
        fi
    done
}

function ssh_config_check {
    local NAME SSHHOSTS HOSTPATTERN
    NAME="$1"
    SSHHOSTS="$2"
    HOSTPATTERN="^Host ${NAME}$"
    if grep "$HOSTPATTERN" "${SSHHOSTS}"; then
        grep "$HOSTPATTERN" -A5 "${SSHHOSTS}"
        echo "${NAME} was found in ${SSHHOSTS}"
        connection_test "$NAME"
        return 1
    else
        return 0
    fi
}
function ssh_config_add_host {
    local NAME SSHHOSTS DIP PATHTOPRIVKEY
    NAME="$1"
    SSHHOSTS="$2"
    DIP="$3"
    PATHTOPRIVKEY="$4"
    echo "Host ${NAME}
    HostName ${DIP}
    User root
    IdentityFile ${PATHTOPRIVKEY}
    IdentitiesOnly yes
    " >> "${SSHHOSTS}"
}

function ansible_add_host {
    local NAME ANSHOSTS DIP PATHTOPRIVKEY OLDIP HOSTPATTERN
    NAME="$1"
    ANSHOSTS="$2"
    DIP="$3"
    HOSTPATTERN="^${NAME} "
    if grep "$HOSTPATTERN" "${ANSHOSTS}"; then
        echo "/n"
        read -p "${NAME} was found in ${ANSHOSTS}, update it with new IP? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Changing IP for $NAME in $ANSHOSTS"
            OLDIP=$(grep "$HOSTPATTERN" $ANSHOSTS | cut -d'=' -f3)
            [ ! $? -eq 0 ] && return 1
            sed "s/${OLDIP}/${DIP}/g" "$ANSHOSTS" > "${TMP}/anshosts"
            cat "${TMP}/anshosts" > "$ANSHOSTS"
            [ ! $? -eq 0 ] && return 1
        elif [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "Cancelled due to user request"
            return 0
        else
            return 1
        fi
    else
        echo "${NAME} ansible_port=22 ansible_host=${DIP}" >> "${ANSHOSTS}"
        [ ! $? -eq 0 ] && return 1
    fi
    return 0
}

function do_add_record {
    local SUBDOMAIN DOMAIN DIP FQDN DNSRAW DNSID
    SUBDOMAIN="$1"
    DOMAIN="$2"
    DIP="$3"
    FQDN="${SUBDOMAIN}.${DOMAIN}"
# TODO find and update matching DNS records
    echo "Setup subdomain with Digitalocean DNS."
    DNSRAW=$(doctl compute domain records \
        create "${DOMAIN}" \
        -t "${DOTOKEN}" \
        --record-type A \
        --record-name "${SUBDOMAIN}" \
        --record-data "${DIP}" \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error creating dns record."
        return 1
    fi
    DNSID=$(echo "${DNSRAW}" | jq '.[0] .id')
    if [ ! $? -eq 0 ] || [ -z "$DNSID" ]; then
        echo "Error parsing JSON."
        echo "${DNSRAW}"
        echo "${DNSID}"
        return 1
    fi
    DNSID=$(echo "${DNSID}" | tr -d '\n')
    if [ -z "$DNSID" ]; then
        echo "DNSID is empty."
        return 1
    else
        echo "DNS A record for ${FQDN} to ${DIP} was created."
    fi
    return 0
}

main "$@"
exit 0
