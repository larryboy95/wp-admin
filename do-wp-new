#!/bin/bash

USAGE="
Usage: do-wp-new CONFIGFILE
Provisions a new droplet at Digitalocean and installs WordPress.

Config file vars required, (see do-new-wp.conf.example):
    NAME (alphanumeric and dashes only) 
    DOMAIN
    EMAIL
    DOTOKEN
    PUBLICKEY

ADMINIP is automatically obtained from eth0

Optional vars and their default values:
    SUBDOMAIN defaults to NAME
    SSHHOSTS ~/.ssh/config
    ANSHOSTS /etc/ansible/hosts
    PATHTOPRIVKEY ~/.ssh/id_rsa
    DROPLETSIZE s-1vcpu-1gb
    IMAGE ubuntu-16-04-x64
    REGION sfo2
    WPUSER admin
    WILDCARD boolean defaults true
    ELASTICSEARCH boolean defaults false

Optional vars with no defaults.
Set these to trigger related feature.
    CODEBASE path of webroot to restore
    DB path to (.sql.gz) db to restore
    RESTICCODEBASE id of target snapshot to restore
    RESTICDB id of target db to restore
"
# Print USAGE if no args
if [ $# -eq 0 ]; then
    echo "$USAGE"
    exit 1
fi
SCRIPTDIR=$(dirname "${0}")
CONFIGPARSE="${SCRIPTDIR}/includes/config_parse"
[ -f "$1" ] || { echo "Config file not found"; exit 1; }
[ -f "$CONFIGPARSE" ] || { echo "Includes error"; exit 1; }

function main {
    local FQDN 
    . "$CONFIGPARSE"

    # If host exists then offer to overwrite
    ssh_config_check "$1"
    if [ $? -eq 1 ]; then
        wp_restore "$1"
        exit $?
    fi

    provision_wordpress "$1"

    # Optionally restore a site to new droplet
    if [ ! -z "$DB" ] \
        || [ ! -z "$RESTICDB" ]; then
        wp_restore "$1"
    fi
    echo "
    ***

    https://${FQDN}

    ***
    "
}

# Provision a new droplet
function provision_wordpress {
    . "$CONFIGPARSE"
    # Setup a tmp dir
    TMP="/tmp/do-new-wp"
    [ ! -d "$TMP" ] && mkdir "$TMP"
    # Cleanup on exit
    trap "rm -rf ${TMP}" EXIT	

    # add nonce
    # repeat until no conflicts
    provision_do "$1"
    connection_test "$1"
    install_prerequisite "$1"
    # Run ansible playbook to set up servers
    ansible-playbook "${SCRIPTDIR}/ansible/wordpress.yml" --extra-vars "
        host=${NAME}
        adminip=${ADMINIP}
        mysql_root_password=${MYSQLROOTPASSWORD}
        mysql_wp_password=${MYSQLWPPASSWORD}
        fqdn=${FQDN}
        email=${EMAIL}
        domain=${DOMAIN}
        newcert=${NEWCERT}
        wildcard=${WILDCARD}
        wildcardchain=${WILDCARDCHAIN}
        elasticsearch=${ELASTICSEARCH}"
    if [ ! $? -eq 0 ]; then
        echo "Error running ansible."
        exit 1
    fi
    # Run wordpress-install new / clone repo
    install_wordpress "$1"
}

function install_wordpress {
    . "$CONFIGPARSE"
    wordpress-install \
        "${NAME}" \
        "${FQDN}" \
        "${WPUSER}" \
        "${EMAIL}" \
        "${MYSQLWPPASSWORD}"
    if [ ! $? -eq 0 ]; then
        echo "Error running wordpress-install."
        exit 1
    fi
    # Preserve the fresh config file
    ssh "${NAME}" "cp /var/www/html/wp-config.php /var/www/wp-config.php.fresh"
    if [ ! $? -eq 0 ]; then
        echo "Error copying config file."
        exit 1
    fi
    # Change webroot permissions
    wordpress-permissions "$NAME" dev
    if [ ! $? -eq 0 ]; then
        echo "Error setting permissions."
        exit 1
    fi
}

function provision_do {
    local DIDRAW DID DIPRAW DIP
    . "$CONFIGPARSE"
    # Provision the droplet and store its ID
    echo "Provisioning new droplet for ${NAME}."
    DIDRAW=$(doctl compute droplet create \
        "$NAME" \
        -t "$DOTOKEN" \
        --ssh-keys "$PUBLICKEY" \
        --size "$DROPLETSIZE" \
        --image "$IMAGE" \
        --region "$REGION" \
        --enable-backups \
        --enable-monitoring \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error provisioning droplet."
        echo "${DIDRAW}"
        exit 1
    fi
    DIDRAW=$(echo "${DIDRAW}" | jq '.[0] .id')
    if [ ! $? -eq 0 ]; then
        echo "Error parsing JSON."
        echo "${DIDRAW}"
        exit 1
    fi
    DID=$(echo "${DIDRAW}" | tr -d '\n')
    if [ -z "$DID" ]; then
        echo "Droplet ID is empty."
        exit 1
    else
        echo "Wait three seconds for the IP to become available....."
        sleep 3
    fi
    # Offer to delete droplet on exit
    trap "doctl compute droplet delete -t ${DOTOKEN} ${DID}; sleep 3; doctl compute droplet list -t ${DOTOKEN}" EXIT

    # Get IP
    while true; do
        DIPRAW=$(doctl compute droplet \
            get "${DID}" \
            -t "${DOTOKEN}" \
            -o json) 
        if [ ! $? -eq 0 ]; then
            echo "Error retrieving droplet IP address."
            echo "$DIPRAW"
            exit 1
        fi
        DIPRAW=$(echo "${DIPRAW}" | jq '.[0] .networks.v4[0].ip_address')
        if [ ! $? -eq 0 ]; then
            echo "Error parsing JSON."
            exit 1
        fi
        DIP=$(echo "${DIPRAW}" | tr -d '\n' | tr -d '"')
        if [ -z "$DIP" ]; then
            echo "IP address is empty?"
            exit 1
        else
            break
        fi
    done

    # Get IP, setup SSH and Ansible config, create DNS A record
    ssh_config_add_host "$1" "$DIP" \
        || { echo "ssh config error $?"; exit 2; }
    ansible_add_host "$1" "$DIP" \
        || { echo "ansible config error $?"; exit 2; }
    do_add_record "$1" "$DIP" \
        || { echo "dns config error $?"; exit 2; }
}

function install_prerequisite {
    . "$CONFIGPARSE"
    [ -z "$NAME" ] && { echo "NAME not set"; exit 1; }
    echo "Install prerequisite packages."
    while true; do
        ssh -o ConnectTimeout=3 "${NAME}" \
            "DEBIAN_FRONTEND=noninteractive apt-get -y -q install python ssl-cert"
        if [ $? -eq 0 ]; then
            sleep 3
            break
        else
            echo "Error installing packages, trying again..."
        fi
    done
    ssh "$NAME" "curl -O https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar; chmod +x wp-cli.phar; mv wp-cli.phar /usr/local/bin/wp"
    if [ ! $? -eq 0 ]; then
        echo "Error installing wp-cli."
        exit 1
    fi
}

# Optionally run a restoration
function wp_restore {
    . "$CONFIGPARSE"
    if [ ! -z "$DB" ]; then
        read -p "Restore ${DB} to ${NAME}? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-local "$NAME" "$FQDN" "$DB" "$CODEBASE"
        else
            return 1
        fi
    elif [ -f ~/.wp-admin ] && [ ! -z "$RESTICDB" ]; then
        read -p "Restore restic snapshot ${RESTICDB} to ${NAME}? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            do-wp-restore-restic "$NAME" "$FQDN" "$RESTICDB" "$RESTICCODEBASE"
        else
            return 1
        fi
    fi
}

# Wait for the new droplet to become ready
function connection_test {
    . "$CONFIGPARSE"
    echo -ne "Wait for the droplet to become available..."
    while true; do
        ssh -o ConnectTimeout=3 -q "${NAME}" \
            "[ -f /var/lib/cloud/instance/boot-finished ]"
        if [ $? -eq 0 ]; then
            sleep 1
            echo -ne "\r"
            break
        else
            echo -ne "."
            sleep 1
        fi
    done
}

function ssh_config_check {
    local HOSTPATTERN
    . "$CONFIGPARSE"
    HOSTPATTERN="^Host ${NAME}$"
    if grep "$HOSTPATTERN" "${SSHHOSTS}"; then
        grep "$HOSTPATTERN" -A5 "${SSHHOSTS}"
        echo "${NAME} was found in ${SSHHOSTS}"
        connection_test "$1"
        return 1
    else
        return 0
    fi
}
function ssh_config_add_host {
    . "$CONFIGPARSE"
    DIP="$2"
    echo "Host ${NAME}
    HostName ${DIP}
    User root
    IdentityFile ${PATHTOPRIVKEY}
    IdentitiesOnly yes
    " >> "${SSHHOSTS}"
}

function ansible_add_host {
    local DIP OLDIP HOSTPATTERN
    . "$CONFIGPARSE"
    DIP="$2"
    HOSTPATTERN="^${NAME} "
    if grep "$HOSTPATTERN" "${ANSHOSTS}"; then
        echo "/n"
        read -p "${NAME} was found in ${ANSHOSTS}, update it with new IP? (y/n)" -n 1 -r
        echo "/n"
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo "Changing IP for $NAME in $ANSHOSTS"
            OLDIP=$(grep "$HOSTPATTERN" $ANSHOSTS | cut -d'=' -f3)
            [ ! $? -eq 0 ] && return 1
            sed "s/${OLDIP}/${DIP}/g" "$ANSHOSTS" > "${TMP}/anshosts"
            cat "${TMP}/anshosts" > "$ANSHOSTS"
            [ ! $? -eq 0 ] && return 1
        elif [[ $REPLY =~ ^[Nn]$ ]]; then
            echo "Cancelled due to user request"
            return 0
        else
            return 1
        fi
    else
        echo "${NAME} ansible_port=22 ansible_host=${DIP}" >> "${ANSHOSTS}"
        [ ! $? -eq 0 ] && return 1
    fi
    return 0
}

function do_add_record {
    local DIP DNSRAW DNSID
    . "$CONFIGPARSE"
    DIP="$2"
# TODO find and update matching DNS records
    echo "Setup subdomain with Digitalocean DNS."
    DNSRAW=$(doctl compute domain records \
        create "${DOMAIN}" \
        -t "${DOTOKEN}" \
        --record-type A \
        --record-name "${SUBDOMAIN}" \
        --record-data "${DIP}" \
        -o json
        )
    if [ ! $? -eq 0 ]; then
        echo "Error creating dns record."
        return 1
    fi
    DNSID=$(echo "${DNSRAW}" | jq '.[0] .id')
    if [ ! $? -eq 0 ] || [ -z "$DNSID" ]; then
        echo "Error parsing JSON."
        echo "${DNSRAW}"
        echo "${DNSID}"
        return 1
    fi
    DNSID=$(echo "${DNSID}" | tr -d '\n')
    if [ -z "$DNSID" ]; then
        echo "DNSID is empty."
        return 1
    else
        echo "DNS A record for ${FQDN} to ${DIP} was created."
    fi
    return 0
}

main "$@"
exit 0
